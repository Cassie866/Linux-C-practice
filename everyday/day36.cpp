#include<iostream>
#include<cmath>

typedeflonglong_sint64;
//有理数类的声明
classRationalNumber
{
	boolm_infinate;
//处理除数为零
boolm_negative;//处理负数_sint64m_numerator;//分子，方便输出_sint64m_denominator;//分母_sint64m_integer; //整数部分_sint64m_numeratorAll; //记录无整数分数的分子，方便进行运算_sint64calcGCD(_sint64a,_sint64b); //求最大公约数的函数public:RationalNumber(_sint64numerator,_sint64denominator); //构造函数RationalNumberoperator+(RationalNumberconst&o)const; //四则运算重载RationalNumberoperator-(RationalNumberconst&o)const;RationalNumberoperator*(RationalNumberconst&o)const;RationalNumberoperator/(RationalNumberconst&o)const;//输出流运算符重载friendstd::ostream&operator<<(std::ostream&os,RationalNumberconst&o);};//有理数类每个方法的实现_sint64RationalNumber::calcGCD(_sint64a,_sint64b){if(b==0){returna;}//辗转相除法returncalcGCD(b,a%b);}RationalNumber::RationalNumber(_sint64numerator,_sint64denominator){m_negative=false;m_infinate=false;//处理分母为零的情况if(denominator==0){m_infinate=true;return;}//这里这样写，是因为在通过计算结果进行构造过程中，有可能出现分子分母均为负的情况。if(numerator<0){m_negative=!m_negative;}if(denominator<0){
m_negative=!m_negative;}//计算整数、分子、分母。其中分母要参与下面的运算，所以不能是负的，用abs取绝对值，分子要保留原值m_integer=numerator/denominator;m_numerator=numerator-m_integer*denominator;m_denominator=abs(denominator);//约分，注意传给子函数的分子必须是正的，分母上面处理过了if(m_numerator){_sint64maxtmp=calcGCD(abs(m_numerator),m_denominator);if(maxtmp){m_numerator/=maxtmp;m_denominator/=maxtmp;}}//计算约分后假分数版的分子，因为后续运算是不需要整数部分的，所以必须用假分数的分子算。m_numeratorAll=m_numerator+m_integer*m_denominator;}//以下为分数的加减乘除，统统使用m_numeratorAll（假分数的分子）进行运算。RationalNumberRationalNumber::operator+(RationalNumberconst&o)const{_sint64numerator=(m_numeratorAll*o.m_denominator)+(o.m_numeratorAll*m_denominator);_sint64denominator=m_denominator*o.m_denominator;returnRationalNumber(numerator,denominator);}RationalNumberRationalNumber::operator-(RationalNumberconst&o)const{_sint64numerator=(m_numeratorAll*o.m_denominator)-(o.m_numeratorAll*m_denominator);_sint64denominator=m_denominator*o.m_denominator;returnRationalNumber(numerator,denominator);}RationalNumberRationalNumber::operator*(RationalNumberconst&o)const{_sint64numerator=m_numeratorAll*o.m_numeratorAll;_sint64denominator=m_denominator*o.m_denominator;returnRationalNumber(numerator,denominator);}RationalNumberRationalNumber::operator/(RationalNumberconst&o)const{
_sint64numerator=m_numeratorAll*o.m_denominator;_sint64denominator=m_denominator*o.m_numeratorAll;returnRationalNumber(numerator,denominator);}std::ostream&operator<<(std::ostream&os,RationalNumberconst&o){//分母为0的情况就不用继续了if(o.m_infinate){os<<"Inf";returnos;}//整数和分子为0那干脆就是0了if(o.m_numerator==0&&o.m_integer==0){os<<"0";returnos;}//负数打印括号和负号if(o.m_negative){os<<"(-";}//有整数就打整数if(o.m_integer){os<<abs(o.m_integer);if(o.m_numerator)//整数小数都有就打个空格隔开{os<<"";}}//有分数就打分数，分母已经abs过了，这里可以不用if(o.m_numerator){os<<abs(o.m_numerator)<<'/'<<o.m_denominator;}//负数的后半边括号if(o.m_negative){os<<")";}returnos;}
